{
  "meta": {
    "buildId": "build-1769085209695",
    "repoOwner": "AnouarY02",
    "repoName": "ai-app-saas",
    "branch": "build-1769085209695",
    "appName": "TaskManager",
    "baseBranch": "main"
  },
  "functionalitySpec": {
    "apiContracts": [
      {
        "endpoint": "/api/auth/register",
        "method": "POST",
        "description": "Register a new user with email and password",
        "dependencies": [
          {
            "package": "zod",
            "version": "^3.22.0",
            "importStatement": "import { z } from 'zod';"
          },
          {
            "package": "bcrypt",
            "version": "^5.1.1",
            "importStatement": "import bcrypt from 'bcrypt';"
          },
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/auth.types",
            "importStatement": "import { RegisterRequest, RegisterResponse, AuthError } from '@/shared/types/auth.types';"
          },
          {
            "from": "@/shared/schemas/auth.schemas",
            "importStatement": "import { RegisterSchema } from '@/shared/schemas/auth.schemas';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          }
        ],
        "handler": {
          "file": "src/app/api/auth/register/route.ts",
          "signature": "export async function POST(request: Request): Promise<Response>",
          "implementation": "try {\n  const body = await request.json();\n  const validated = RegisterSchema.safeParse(body);\n  if (!validated.success) {\n    return Response.json({ error: 'Invalid input', details: validated.error.errors }, { status: 400 });\n  }\n  const { email, password, name } = validated.data;\n  const existingUser = await db.query('SELECT id FROM users WHERE email = $1', [email]);\n  if (existingUser.rows.length > 0) {\n    return Response.json({ error: 'User already exists' }, { status: 409 });\n  }\n  const passwordHash = await bcrypt.hash(password, 10);\n  const result = await db.query(\n    'INSERT INTO users (email, password_hash, name) VALUES ($1, $2, $3) RETURNING id, email, name',\n    [email, passwordHash, name || null]\n  );\n  const user = result.rows[0];\n  const token = jwt.sign({ userId: user.id, email: user.email }, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });\n  return Response.json({ user: { id: user.id, email: user.email, name: user.name }, token }, { status: 201 });\n} catch (error) {\n  console.error('Registration error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "RegisterRequest",
        "responseType": "RegisterResponse",
        "errorCases": [
          {
            "status": 400,
            "condition": "Invalid input data",
            "message": "Invalid input"
          },
          {
            "status": 409,
            "condition": "Email already registered",
            "message": "User already exists"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      },
      {
        "endpoint": "/api/auth/login",
        "method": "POST",
        "description": "Authenticate user with email and password",
        "dependencies": [
          {
            "package": "zod",
            "version": "^3.22.0",
            "importStatement": "import { z } from 'zod';"
          },
          {
            "package": "bcrypt",
            "version": "^5.1.1",
            "importStatement": "import bcrypt from 'bcrypt';"
          },
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/auth.types",
            "importStatement": "import { LoginRequest, LoginResponse, AuthError } from '@/shared/types/auth.types';"
          },
          {
            "from": "@/shared/schemas/auth.schemas",
            "importStatement": "import { LoginSchema } from '@/shared/schemas/auth.schemas';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          }
        ],
        "handler": {
          "file": "src/app/api/auth/login/route.ts",
          "signature": "export async function POST(request: Request): Promise<Response>",
          "implementation": "try {\n  const body = await request.json();\n  const validated = LoginSchema.safeParse(body);\n  if (!validated.success) {\n    return Response.json({ error: 'Invalid input', details: validated.error.errors }, { status: 400 });\n  }\n  const { email, password } = validated.data;\n  const result = await db.query(\n    'SELECT id, email, password_hash, name FROM users WHERE email = $1',\n    [email]\n  );\n  if (result.rows.length === 0) {\n    return Response.json({ error: 'Invalid credentials' }, { status: 401 });\n  }\n  const user = result.rows[0];\n  const isValidPassword = await bcrypt.compare(password, user.password_hash);\n  if (!isValidPassword) {\n    return Response.json({ error: 'Invalid credentials' }, { status: 401 });\n  }\n  const token = jwt.sign({ userId: user.id, email: user.email }, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });\n  return Response.json({ user: { id: user.id, email: user.email, name: user.name }, token }, { status: 200 });\n} catch (error) {\n  console.error('Login error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "LoginRequest",
        "responseType": "LoginResponse",
        "errorCases": [
          {
            "status": 400,
            "condition": "Invalid input data",
            "message": "Invalid input"
          },
          {
            "status": 401,
            "condition": "Invalid email or password",
            "message": "Invalid credentials"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      },
      {
        "endpoint": "/api/tasks",
        "method": "GET",
        "description": "Get all tasks for authenticated user",
        "dependencies": [
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/task.types",
            "importStatement": "import { Task, GetTasksResponse } from '@/shared/types/task.types';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          },
          {
            "from": "@/lib/auth",
            "importStatement": "import { verifyToken } from '@/lib/auth';"
          }
        ],
        "handler": {
          "file": "src/app/api/tasks/route.ts",
          "signature": "export async function GET(request: Request): Promise<Response>",
          "implementation": "try {\n  const authHeader = request.headers.get('authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return Response.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const token = authHeader.substring(7);\n  let decoded: any;\n  try {\n    decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');\n  } catch (err) {\n    return Response.json({ error: 'Invalid token' }, { status: 401 });\n  }\n  const userId = decoded.userId;\n  const result = await db.query(\n    'SELECT id, title, description, completed, user_id, created_at, updated_at FROM tasks WHERE user_id = $1 ORDER BY created_at DESC',\n    [userId]\n  );\n  const tasks = result.rows.map(row => ({\n    id: row.id,\n    title: row.title,\n    description: row.description,\n    completed: row.completed,\n    userId: row.user_id,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at\n  }));\n  return Response.json({ tasks }, { status: 200 });\n} catch (error) {\n  console.error('Get tasks error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "void",
        "responseType": "GetTasksResponse",
        "errorCases": [
          {
            "status": 401,
            "condition": "Missing or invalid authorization token",
            "message": "Unauthorized"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      },
      {
        "endpoint": "/api/tasks",
        "method": "POST",
        "description": "Create a new task for authenticated user",
        "dependencies": [
          {
            "package": "zod",
            "version": "^3.22.0",
            "importStatement": "import { z } from 'zod';"
          },
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/task.types",
            "importStatement": "import { CreateTaskRequest, CreateTaskResponse, Task } from '@/shared/types/task.types';"
          },
          {
            "from": "@/shared/schemas/task.schemas",
            "importStatement": "import { CreateTaskSchema } from '@/shared/schemas/task.schemas';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          }
        ],
        "handler": {
          "file": "src/app/api/tasks/route.ts",
          "signature": "export async function POST(request: Request): Promise<Response>",
          "implementation": "try {\n  const authHeader = request.headers.get('authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return Response.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const token = authHeader.substring(7);\n  let decoded: any;\n  try {\n    decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');\n  } catch (err) {\n    return Response.json({ error: 'Invalid token' }, { status: 401 });\n  }\n  const userId = decoded.userId;\n  const body = await request.json();\n  const validated = CreateTaskSchema.safeParse(body);\n  if (!validated.success) {\n    return Response.json({ error: 'Invalid input', details: validated.error.errors }, { status: 400 });\n  }\n  const { title, description } = validated.data;\n  const result = await db.query(\n    'INSERT INTO tasks (title, description, completed, user_id) VALUES ($1, $2, $3, $4) RETURNING id, title, description, completed, user_id, created_at, updated_at',\n    [title, description || null, false, userId]\n  );\n  const task = result.rows[0];\n  return Response.json({\n    task: {\n      id: task.id,\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      userId: task.user_id,\n      createdAt: task.created_at,\n      updatedAt: task.updated_at\n    }\n  }, { status: 201 });\n} catch (error) {\n  console.error('Create task error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "CreateTaskRequest",
        "responseType": "CreateTaskResponse",
        "errorCases": [
          {
            "status": 400,
            "condition": "Invalid input data",
            "message": "Invalid input"
          },
          {
            "status": 401,
            "condition": "Missing or invalid authorization token",
            "message": "Unauthorized"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      },
      {
        "endpoint": "/api/tasks/[id]",
        "method": "PUT",
        "description": "Update an existing task",
        "dependencies": [
          {
            "package": "zod",
            "version": "^3.22.0",
            "importStatement": "import { z } from 'zod';"
          },
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/task.types",
            "importStatement": "import { UpdateTaskRequest, UpdateTaskResponse, Task } from '@/shared/types/task.types';"
          },
          {
            "from": "@/shared/schemas/task.schemas",
            "importStatement": "import { UpdateTaskSchema } from '@/shared/schemas/task.schemas';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          }
        ],
        "handler": {
          "file": "src/app/api/tasks/[id]/route.ts",
          "signature": "export async function PUT(request: Request, { params }: { params: { id: string } }): Promise<Response>",
          "implementation": "try {\n  const authHeader = request.headers.get('authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return Response.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const token = authHeader.substring(7);\n  let decoded: any;\n  try {\n    decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');\n  } catch (err) {\n    return Response.json({ error: 'Invalid token' }, { status: 401 });\n  }\n  const userId = decoded.userId;\n  const taskId = params.id;\n  const body = await request.json();\n  const validated = UpdateTaskSchema.safeParse(body);\n  if (!validated.success) {\n    return Response.json({ error: 'Invalid input', details: validated.error.errors }, { status: 400 });\n  }\n  const checkResult = await db.query('SELECT user_id FROM tasks WHERE id = $1', [taskId]);\n  if (checkResult.rows.length === 0) {\n    return Response.json({ error: 'Task not found' }, { status: 404 });\n  }\n  if (checkResult.rows[0].user_id !== userId) {\n    return Response.json({ error: 'Forbidden' }, { status: 403 });\n  }\n  const { title, description, completed } = validated.data;\n  const updates: string[] = [];\n  const values: any[] = [];\n  let paramCount = 1;\n  if (title !== undefined) {\n    updates.push(`title = $${paramCount}`);\n    values.push(title);\n    paramCount++;\n  }\n  if (description !== undefined) {\n    updates.push(`description = $${paramCount}`);\n    values.push(description);\n    paramCount++;\n  }\n  if (completed !== undefined) {\n    updates.push(`completed = $${paramCount}`);\n    values.push(completed);\n    paramCount++;\n  }\n  updates.push(`updated_at = NOW()`);\n  values.push(taskId);\n  const result = await db.query(\n    `UPDATE tasks SET ${updates.join(', ')} WHERE id = $${paramCount} RETURNING id, title, description, completed, user_id, created_at, updated_at`,\n    values\n  );\n  const task = result.rows[0];\n  return Response.json({\n    task: {\n      id: task.id,\n      title: task.title,\n      description: task.description,\n      completed: task.completed,\n      userId: task.user_id,\n      createdAt: task.created_at,\n      updatedAt: task.updated_at\n    }\n  }, { status: 200 });\n} catch (error) {\n  console.error('Update task error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "UpdateTaskRequest",
        "responseType": "UpdateTaskResponse",
        "errorCases": [
          {
            "status": 400,
            "condition": "Invalid input data",
            "message": "Invalid input"
          },
          {
            "status": 401,
            "condition": "Missing or invalid authorization token",
            "message": "Unauthorized"
          },
          {
            "status": 403,
            "condition": "User does not own the task",
            "message": "Forbidden"
          },
          {
            "status": 404,
            "condition": "Task not found",
            "message": "Task not found"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      },
      {
        "endpoint": "/api/tasks/[id]",
        "method": "DELETE",
        "description": "Delete a task",
        "dependencies": [
          {
            "package": "jsonwebtoken",
            "version": "^9.0.2",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ],
        "internalImports": [
          {
            "from": "@/shared/types/task.types",
            "importStatement": "import { DeleteTaskResponse } from '@/shared/types/task.types';"
          },
          {
            "from": "@/lib/db",
            "importStatement": "import { db } from '@/lib/db';"
          }
        ],
        "handler": {
          "file": "src/app/api/tasks/[id]/route.ts",
          "signature": "export async function DELETE(request: Request, { params }: { params: { id: string } }): Promise<Response>",
          "implementation": "try {\n  const authHeader = request.headers.get('authorization');\n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return Response.json({ error: 'Unauthorized' }, { status: 401 });\n  }\n  const token = authHeader.substring(7);\n  let decoded: any;\n  try {\n    decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret');\n  } catch (err) {\n    return Response.json({ error: 'Invalid token' }, { status: 401 });\n  }\n  const userId = decoded.userId;\n  const taskId = params.id;\n  const checkResult = await db.query('SELECT user_id FROM tasks WHERE id = $1', [taskId]);\n  if (checkResult.rows.length === 0) {\n    return Response.json({ error: 'Task not found' }, { status: 404 });\n  }\n  if (checkResult.rows[0].user_id !== userId) {\n    return Response.json({ error: 'Forbidden' }, { status: 403 });\n  }\n  await db.query('DELETE FROM tasks WHERE id = $1', [taskId]);\n  return Response.json({ success: true, message: 'Task deleted successfully' }, { status: 200 });\n} catch (error) {\n  console.error('Delete task error:', error);\n  return Response.json({ error: 'Internal server error' }, { status: 500 });\n}"
        },
        "requestType": "void",
        "responseType": "DeleteTaskResponse",
        "errorCases": [
          {
            "status": 401,
            "condition": "Missing or invalid authorization token",
            "message": "Unauthorized"
          },
          {
            "status": 403,
            "condition": "User does not own the task",
            "message": "Forbidden"
          },
          {
            "status": 404,
            "condition": "Task not found",
            "message": "Task not found"
          },
          {
            "status": 500,
            "condition": "Server error",
            "message": "Internal server error"
          }
        ]
      }
    ],
    "sharedTypes": [
      {
        "name": "User",
        "file": "src/shared/types/user.types.ts",
        "definition": "export interface User {\n  id: string;\n  email: string;\n  name: string | null;\n}\n\nexport interface UserWithPassword extends User {\n  passwordHash: string;\n}"
      },
      {
        "name": "RegisterRequest",
        "file": "src/shared/types/auth.types.ts",
        "definition": "export interface RegisterRequest {\n  email: string;\n  password: string;\n  name?: string;\n}\n\nexport interface RegisterResponse {\n  user: {\n    id: string;\n    email: string;\n    name: string | null;\n  };\n  token: string;\n}\n\nexport interface LoginRequest {\n  email: string;\n  password: string;\n}\n\nexport interface LoginResponse {\n  user: {\n    id: string;\n    email: string;\n    name: string | null;\n  };\n  token: string;\n}\n\nexport interface AuthError {\n  error: string;\n  details?: any;\n}"
      },
      {
        "name": "Task",
        "file": "src/shared/types/task.types.ts",
        "definition": "export interface Task {\n  id: string;\n  title: string;\n  description: string | null;\n  completed: boolean;\n  userId: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface CreateTaskRequest {\n  title: string;\n  description?: string;\n}\n\nexport interface CreateTaskResponse {\n  task: Task;\n}\n\nexport interface UpdateTaskRequest {\n  title?: string;\n  description?: string;\n  completed?: boolean;\n}\n\nexport interface UpdateTaskResponse {\n  task: Task;\n}\n\nexport interface GetTasksResponse {\n  tasks: Task[];\n}\n\nexport interface DeleteTaskResponse {\n  success: boolean;\n  message: string;\n}\n\nexport interface TaskError {\n  error: string;\n  details?: any;\n}"
      }
    ],
    "schemas": [
      {
        "name": "RegisterSchema",
        "file": "src/shared/schemas/auth.schemas.ts",
        "definition": "import { z } from 'zod';\n\nexport const RegisterSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(8, 'Password must be at least 8 characters'),\n  name: z.string().optional()\n});",
        "dependencies": [
          {
            "package": "zod",
            "importStatement": "import { z } from 'zod';"
          }
        ]
      },
      {
        "name": "LoginSchema",
        "file": "src/shared/schemas/auth.schemas.ts",
        "definition": "import { z } from 'zod';\n\nexport const LoginSchema = z.object({\n  email: z.string().email('Invalid email address'),\n  password: z.string().min(1, 'Password is required')\n});",
        "dependencies": [
          {
            "package": "zod",
            "importStatement": "import { z } from 'zod';"
          }
        ]
      },
      {
        "name": "CreateTaskSchema",
        "file": "src/shared/schemas/task.schemas.ts",
        "definition": "import { z } from 'zod';\n\nexport const CreateTaskSchema = z.object({\n  title: z.string().min(1, 'Title is required').max(255, 'Title too long'),\n  description: z.string().max(1000, 'Description too long').optional()\n});",
        "dependencies": [
          {
            "package": "zod",
            "importStatement": "import { z } from 'zod';"
          }
        ]
      },
      {
        "name": "UpdateTaskSchema",
        "file": "src/shared/schemas/task.schemas.ts",
        "definition": "import { z } from 'zod';\n\nexport const UpdateTaskSchema = z.object({\n  title: z.string().min(1, 'Title is required').max(255, 'Title too long').optional(),\n  description: z.string().max(1000, 'Description too long').optional(),\n  completed: z.boolean().optional()\n}).refine(data => Object.keys(data).length > 0, {\n  message: 'At least one field must be provided'\n});",
        "dependencies": [
          {
            "package": "zod",
            "importStatement": "import { z } from 'zod';"
          }
        ]
      }
    ],
    "databaseSchema": {
      "tables": [
        {
          "name": "users",
          "columns": [
            {
              "name": "id",
              "type": "UUID PRIMARY KEY DEFAULT gen_random_uuid()"
            },
            {
              "name": "email",
              "type": "VARCHAR(255) UNIQUE NOT NULL"
            },
            {
              "name": "password_hash",
              "type": "VARCHAR(255) NOT NULL"
            },
            {
              "name": "name",
              "type": "VARCHAR(255)"
            },
            {
              "name": "created_at",
              "type": "TIMESTAMP DEFAULT NOW()"
            },
            {
              "name": "updated_at",
              "type": "TIMESTAMP DEFAULT NOW()"
            }
          ],
          "indexes": [
            {
              "name": "idx_users_email",
              "columns": [
                "email"
              ]
            }
          ]
        },
        {
          "name": "tasks",
          "columns": [
            {
              "name": "id",
              "type": "UUID PRIMARY KEY DEFAULT gen_random_uuid()"
            },
            {
              "name": "title",
              "type": "VARCHAR(255) NOT NULL"
            },
            {
              "name": "description",
              "type": "TEXT"
            },
            {
              "name": "completed",
              "type": "BOOLEAN DEFAULT FALSE NOT NULL"
            },
            {
              "name": "user_id",
              "type": "UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE"
            },
            {
              "name": "created_at",
              "type": "TIMESTAMP DEFAULT NOW()"
            },
            {
              "name": "updated_at",
              "type": "TIMESTAMP DEFAULT NOW()"
            }
          ],
          "indexes": [
            {
              "name": "idx_tasks_user_id",
              "columns": [
                "user_id"
              ]
            },
            {
              "name": "idx_tasks_completed",
              "columns": [
                "completed"
              ]
            }
          ]
        }
      ]
    },
    "utilityFiles": [
      {
        "name": "db",
        "file": "src/lib/db.ts",
        "definition": "import { Pool } from 'pg';\n\nexport const db = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n});",
        "dependencies": [
          {
            "package": "pg",
            "importStatement": "import { Pool } from 'pg';"
          }
        ]
      },
      {
        "name": "auth",
        "file": "src/lib/auth.ts",
        "definition": "import jwt from 'jsonwebtoken';\n\nexport interface TokenPayload {\n  userId: string;\n  email: string;\n}\n\nexport function verifyToken(token: string): TokenPayload {\n  return jwt.verify(token, process.env.JWT_SECRET || 'secret') as TokenPayload;\n}\n\nexport function generateToken(payload: TokenPayload): string {\n  return jwt.sign(payload, process.env.JWT_SECRET || 'secret', { expiresIn: '7d' });\n}",
        "dependencies": [
          {
            "package": "jsonwebtoken",
            "importStatement": "import jwt from 'jsonwebtoken';"
          }
        ]
      }
    ]
  }
}