// Auth controller
import { Request, Response } from 'express';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { userRepository } from '../repositories/userRepository';
import { sessionRepository } from '../repositories/sessionRepository';
import { hashPassword, verifyPassword } from '../utils/passwordUtils';
import { signJwt } from '../utils/jwtUtils';

const signupRequestSchema = z.object({
  email: z.string().email(),
  password: z.string().min(6),
  name: z.string().optional(),
});

const loginRequestSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1),
});

const logoutRequestSchema = z.object({
  token: z.string().min(1),
});

export const authController = {
  async signup(req: Request, res: Response) {
    const parse = signupRequestSchema.safeParse(req.body);
    if (!parse.success) {
      return res.status(400).json({ error: 'Invalid signup data' });
    }
    const { email, password, name } = parse.data;
    const existing = await userRepository.findByEmail(email);
    if (existing) {
      return res.status(409).json({ error: 'Email already registered' });
    }
    const passwordHash = await hashPassword(password);
    const now = new Date();
    const user = await userRepository.create({
      id: uuidv4(),
      email,
      passwordHash,
      name: name || '',
      createdAt: now,
      updatedAt: now,
    });
    const token = signJwt(user);
    await sessionRepository.create({
      id: uuidv4(),
      userId: user.id,
      token,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      createdAt: now,
    });
    res.cookie('token', token, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    res.status(201).json({ user: { ...user, passwordHash: undefined }, token });
  },

  async login(req: Request, res: Response) {
    const parse = loginRequestSchema.safeParse(req.body);
    if (!parse.success) {
      return res.status(400).json({ error: 'Invalid login data' });
    }
    const { email, password } = parse.data;
    const user = await userRepository.findByEmail(email);
    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const valid = await verifyPassword(password, user.passwordHash);
    if (!valid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }
    const token = signJwt(user);
    await sessionRepository.create({
      id: uuidv4(),
      userId: user.id,
      token,
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
      createdAt: new Date(),
    });
    res.cookie('token', token, {
      httpOnly: true,
      sameSite: 'lax',
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60 * 1000,
    });
    res.status(200).json({ user: { ...user, passwordHash: undefined }, token });
  },

  async logout(req: Request, res: Response) {
    const parse = logoutRequestSchema.safeParse(req.body);
    if (!parse.success) {
      return res.status(400).json({ error: 'Invalid logout data' });
    }
    const { token } = parse.data;
    await sessionRepository.deleteByToken(token);
    res.clearCookie('token');
    res.status(200).json({ success: true });
  },
};

